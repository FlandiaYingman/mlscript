:js


case x then x
//│ = [Function (anonymous)]

:sjs
case { x then x }
//│ JS (unsanitized):
//│ (caseScrut) => { let x; x = caseScrut; return x; }
//│ = [Function (anonymous)]

:sjs
x => if x is
  0 then true
//│ JS (unsanitized):
//│ (x) => { if (x === 0) { return true; } else { throw new this.Error("match error"); } }
//│ = [Function (anonymous)]

:sjs
case 0 then true
//│ JS (unsanitized):
//│ (caseScrut) => {
//│   if (caseScrut === 0) {
//│     return true;
//│   } else {
//│     throw new this.Error("match error");
//│   }
//│ }
//│ = [Function (anonymous)]

(case x then x) of 1
//│ = 1

1 |> case x then x
//│ = 1

1 |> id of case x then x
//│ = 1

[1] |> case [x] then x
//│ = 1

1 |> (2 |> case x then case y then [x, y]) |> case [a, b] then [b, a]
//│ = [ 1, 2 ]

:todo
case [x] then x, [] then 0
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(Tup(List()),keyword 'then',IntLit(0)) (of class hkmc2.syntax.Tree$InfixApp)

:sjs
case
  0 then true
  _ then false
//│ JS (unsanitized):
//│ (caseScrut) => { if (caseScrut === 0) { return true; } else { return false; } }
//│ = [Function (anonymous)]

class Some(value)
module None

:sjs
val isDefined = case
  Some then true
  None then false
//│ JS (unsanitized):
//│ let isDefined, tmp5;
//│ tmp5 = (caseScrut) => {
//│   if (caseScrut instanceof Some1.class) {
//│     return true;
//│   } else {
//│     if (caseScrut instanceof None1) {
//│       return false;
//│     } else {
//│       throw new this.Error("match error");
//│     }
//│   }
//│ };
//│ isDefined = tmp5;
//│ null
//│ isDefined = [Function: tmp5]

