:js


// * Note how we avoid the name clash between the internal name `Test` of the class
// * and the external name `Test1` of its singleton instance.
:sjs
object Test with
  val x = 12
  fun foo() =
    print(Test)
    Test.x
//│ JS (unsanitized):
//│ let Test1;
//│ const Test$class = class Test {
//│   constructor() {
//│     this.x = 12;
//│   }
//│   foo() {
//│     let tmp;
//│     tmp = Predef.print(Test1);
//│     return Test1.x;
//│   }
//│   toString() { return "Test"; }
//│ }; Test1 = new Test$class;
//│ Test1.class = Test$class;
//│ null

Test
//│ = Test { x: 12, class: [class Test] }

print(Test)
//│ > Test

:sjs
Test.foo()
//│ JS (unsanitized):
//│ Test1.foo()
//│ > Test
//│ = 12

:sjs
val Test = "oops"
//│ JS (unsanitized):
//│ let Test3; Test3 = "oops"; null
//│ Test = 'oops'

:re
Test.foo()
//│ ═══[RUNTIME ERROR] TypeError: Test3.foo is not a function


:sjs
let x = 1
let f = () => x
let x = 2
f()
//│ JS (unsanitized):
//│ let x, f, x1; x = 1; f = () => { return x; }; x1 = 2; f() ?? null
//│ = 1
//│ f = [Function: f]
//│ x = 2


:sjs
module Test with
  val x = 1
  let x = 2
//│ JS (unsanitized):
//│ let Test5;
//│ const Test$class1 = class Test {
//│   #x;
//│   constructor() {
//│     this.x = 1;
//│     this.#x = 2;
//│   }
//│   toString() { return "Test"; }
//│ }; Test5 = new Test$class1;
//│ Test5.class = Test$class1;
//│ null

Test.x
//│ = 1


module Test with
  let x = 1
  let f = () => x
  let x = 2
  print(f())
//│ > 1


:sjs
class Cls(x) with
  let x += 1
  fun foo = x
  let x *= 2
  fun bar = x
  print(this.x, x)
//│ JS (unsanitized):
//│ let Cls1;
//│ Cls1 = function Cls(x3) { return new Cls.class(x3); };
//│ Cls1.class = class Cls {
//│   #x;
//│   #x1;
//│   constructor(x2) {
//│     this.x = x2;
//│     let tmp, tmp1;
//│     tmp = this.x + 1;
//│     this.#x = tmp;
//│     tmp1 = this.#x * 2;
//│     this.#x1 = tmp1;
//│     Predef.print(this.x, this.#x1)
//│   }
//│   get foo() {
//│     return this.#x;
//│   } 
//│   get bar() {
//│     return this.#x1;
//│   }
//│   toString() { return "Cls(" + this.x + ")"; }
//│ };
//│ null

let cls = Cls(10)
//│ > 10 22
//│ cls = Cls { x: 10 }

:expect 10
cls.x
//│ = 10

:expect 11
cls.foo
//│ = 11

:expect 22
cls.bar
//│ = 22


fun foo() =
  if false then
    module A
    A
  else
    module A
    A

foo()
//│ = A { class: [class A] }


